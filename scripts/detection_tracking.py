# -*- coding: utf-8 -*-

import core.test_engine as infer_engine
from core.config import cfg
from core.config import merge_cfg_from_file
from core.config import assert_and_infer_cfg
import cv2
import utils.c2 as c2_utils
import numpy as np
import rospy
from sensor_msgs.msg import Image
from cv_bridge import CvBridge, CvBridgeError

class Detector:
    def __init__(self):
        weights_file = "/home/kollmitz/tools/detectron_depth/trained_models/googlenet_xxs_RGB_hospital/train/hospital_train_RGB_Depth/generalized_rcnn/model_final.pkl"
        config_file = "/home/kollmitz/tools/detectron_depth/configs/hospital_detection/faster_rcnn_googlenet_xxs_RGB.yaml"
        merge_cfg_from_file(config_file)
        cfg.TEST.WEIGHTS = weights_file
        cfg.NUM_GPUS = 1
    
        assert_and_infer_cfg()
        self.model = infer_engine.initialize_model_from_cfg()
        self.bridge = CvBridge()
    
        rospy.Subscriber("/kinect2/qhd/image_color_rect", Image, self.image_callback) 
        self.viz_pub = rospy.Publisher("mobility_aids/vis", Image)
        
        self.last_image = None
        self.new_image = False

    def convert_from_cls_format(self, cls_boxes, cls_depths):
        """Convert from the class boxes/segms/keyps format generated by the testing
        code.
        """
        box_list = [b for b in cls_boxes if len(b) > 0]
        if len(box_list) > 0:
            boxes = np.concatenate(box_list)
        else:
            boxes = None
        if cls_depths is not None:
            depth_list = [b for b in cls_depths if len(b) > 0]
            if len(depth_list) > 0:
                depths = np.concatenate(depth_list)
            else:
                depths = None
        else:
            depths = None
        classes = []
        for j in range(len(cls_boxes)):
            classes += [j] * len(cls_boxes[j])
        return boxes, depths, classes

    def visualize_image(self, image, boxes, depths, thresh=0.9):
        
        # one threshold per class
        if isinstance(thresh, float):
            thresh = thresh * np.ones(cfg.MODEL.NUM_CLASSES)
        
        boxes, depths, classes = self.convert_from_cls_format(boxes, depths)
        
        if boxes is None or boxes.shape[0] == 0:
            return
        
        # Display in largest to smallest order to reduce occlusion
        areas = (boxes[:, 2] - boxes[:, 0]) * (boxes[:, 3] - boxes[:, 1])
        sorted_inds = np.argsort(-areas)
        
        #{'person'}    {'crutches'}    {'walking_frame'}    {'wheelchair'}    {'push_wheelchair'}
        colors_box = [[1, 1, 1],
                      [39,167,0],
                      [0,0,191],
                      [0,255,255],
                      [26,126,26],
                      [101,0,255]]
        
        for i in sorted_inds:
            bbox = boxes[i, :4]
            score = boxes[i, -1]
            cla = classes[i]
            if score < thresh[cla]:
                continue
    
            # draw bbox
            color_box = colors_box[cla]
            
            cv2.rectangle(image, (bbox[0], bbox[1]), (bbox[2], bbox[3]), color_box, 3)
            
        #    cv2.imshow('image',image)
        #    cv2.waitKey(0)
        #    cv2.destroyAllWindows()

    def process_last_image(self):
        
        if self.new_image:
            with c2_utils.NamedCudaScope(0):
                cls_boxes, cls_depths, cls_segms, cls_keyps = infer_engine.im_detect_all(
                    self.model, self.last_image, None)
            
            self.visualize_image(self.last_image, cls_boxes, cls_depths)
            self.viz_pub.publish(self.bridge.cv2_to_imgmsg(self.last_image, encoding="passthrough"))
            
            self.new_image = False

    def image_callback(self, data):
        
        try:
            self.last_image = self.bridge.imgmsg_to_cv2(data, "passthrough")
            self.new_image = True
            
        except CvBridgeError as e:
            print(e)
            return

def main(args):
    
    rospy.init_node('detector', anonymous=True)
    det = Detector();
    
    print "waiting for images ..."
    rate = rospy.Rate(30)
    
    while not rospy.is_shutdown():
        det.process_last_image()
        rate.sleep()
    
    print "done"
    
if __name__ == '__main__':
    main(None)